{"ast":null,"code":"var _jsxFileName = \"/Users/ayush/Desktop/Hacks/speech-to-text-app/src/App.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from \"react\";\nimport \"./App.css\";\n\n// Helper function to determine if a sentence should be considered a question.\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction isQuestionSentence(sentence) {\n  sentence = sentence.trim();\n  if (sentence.length === 0) return false;\n\n  // Split the sentence into individual words.\n  const words = sentence.split(/\\s+/);\n  const firstWord = words[0].toLowerCase();\n\n  // Words that indicate a question only if they appear at the beginning.\n  const startOnlyIndicators = [\"is\", \"are\", \"am\", \"was\", \"were\", \"do\", \"does\", \"did\", \"can\", \"could\", \"would\", \"should\", \"will\", \"shall\"];\n  // Words that may indicate a question regardless of position.\n  const generalIndicators = [\"what\", \"why\", \"how\", \"when\", \"where\", \"who\"];\n\n  // Check if the first word is a question indicator.\n  if (startOnlyIndicators.includes(firstWord) || generalIndicators.includes(firstWord)) {\n    return true;\n  }\n\n  // For sentences with at least 4 words, also check the second word for start-only indicators.\n  if (words.length >= 4) {\n    const secondWord = words[1].toLowerCase();\n    if (startOnlyIndicators.includes(secondWord)) {\n      return true;\n    }\n  }\n\n  // Check the rest of the sentence for any general question indicators.\n  for (let word of words.slice(1)) {\n    if (generalIndicators.includes(word.toLowerCase())) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// Helper function to format a sentence by trimming, capitalizing, and adding punctuation.\nfunction formatSentence(sentence) {\n  sentence = sentence.trim();\n  if (sentence.length === 0) return \"\";\n  const isQuestion = isQuestionSentence(sentence);\n\n  // Capitalize the first letter.\n  sentence = sentence.charAt(0).toUpperCase() + sentence.slice(1);\n\n  // Append punctuation if none exists.\n  if (!/[.!?]$/.test(sentence)) {\n    sentence += isQuestion ? \"?\" : \".\";\n  }\n  return sentence;\n}\n\n// Set up the Web Speech API for speech recognition.\nconst SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\nconst recognition = new SpeechRecognition();\nrecognition.continuous = true;\nrecognition.interimResults = true;\nrecognition.lang = \"en-US\";\nfunction App() {\n  _s();\n  // States for recording and transcript data.\n  const [isRecording, setIsRecording] = useState(false);\n  const [finalTranscript, setFinalTranscript] = useState(\"\");\n  const [interimTranscript, setInterimTranscript] = useState(\"\");\n  // New state: only the newly finalized chunk.\n  const [newFinalChunk, setNewFinalChunk] = useState(\"\");\n\n  // States for connection and message statuses.\n  const [connectionStatus, setConnectionStatus] = useState(\"Disconnected\");\n  const [messageStatus, setMessageStatus] = useState(\"\");\n\n  // Ref for the transcript display (for auto-scrolling).\n  const containerRef = useRef(null);\n\n  // State to hold the WebSocket instance.\n  const [socket, setSocket] = useState(null);\n\n  // WebSocket connection effect with reconnection every 5 seconds if disconnected.\n  useEffect(() => {\n    let ws;\n    let reconnectIntervalId;\n    const connect = () => {\n      try {\n        ws = new WebSocket(\"ws://localhost:8080\"); // Update this URL as needed.\n        ws.onopen = () => {\n          console.log(\"Connected to WebSocket server\");\n          setConnectionStatus(\"Connected\");\n          setSocket(ws);\n          // Clear any running reconnection interval.\n          if (reconnectIntervalId) {\n            clearInterval(reconnectIntervalId);\n            reconnectIntervalId = null;\n          }\n        };\n        ws.onclose = () => {\n          console.log(\"WebSocket connection closed\");\n          setConnectionStatus(\"Disconnected\");\n          setSocket(null);\n          // If not already reconnecting, start trying every 5 seconds.\n          if (!reconnectIntervalId) {\n            reconnectIntervalId = setInterval(() => {\n              console.log(\"Attempting to reconnect to WebSocket server...\");\n              connect();\n            }, 5000);\n          }\n        };\n        ws.onerror = error => {\n          console.error(\"WebSocket error:\", error);\n          ws.close(); // Force a close to trigger the reconnect logic in onclose.\n        };\n      } catch (error) {\n        console.error(\"WebSocket connection error:\", error);\n        setConnectionStatus(\"Disconnected\");\n      }\n    };\n    connect();\n\n    // Cleanup on component unmount.\n    return () => {\n      if (reconnectIntervalId) clearInterval(reconnectIntervalId);\n      if (ws) ws.close();\n    };\n  }, []);\n\n  // Set up speech recognition event handlers.\n  useEffect(() => {\n    recognition.onresult = event => {\n      let final = \"\";\n      let interim = \"\";\n      // Process each result from speech recognition.\n      for (let i = event.resultIndex; i < event.results.length; i++) {\n        const transcript = event.results[i][0].transcript;\n        if (event.results[i].isFinal) {\n          final += transcript;\n        } else {\n          interim += transcript;\n        }\n      }\n      // If finalized text exists, format it, update cumulative transcript, and capture the new chunk.\n      if (final) {\n        const formattedFinal = formatSentence(final);\n        setFinalTranscript(prev => prev + \" \" + formattedFinal);\n        setNewFinalChunk(formattedFinal);\n      }\n      // Update interim text for real-time display.\n      setInterimTranscript(interim);\n    };\n    recognition.onerror = event => {\n      console.error(\"Speech recognition error:\", event.error);\n    };\n    recognition.onend = () => {\n      console.log(\"Speech recognition ended.\");\n      if (isRecording) {\n        console.log(\"Restarting speech recognition...\");\n        recognition.start();\n      }\n    };\n  }, [isRecording]);\n\n  // Periodically refresh the speech recognition session (every 50 seconds) to prevent browser timeout.\n  useEffect(() => {\n    if (!isRecording) return;\n    const refreshInterval = 50000; // 50 seconds.\n    const intervalID = setInterval(() => {\n      console.log(\"Refreshing recognition session...\");\n      recognition.stop();\n    }, refreshInterval);\n    return () => clearInterval(intervalID);\n  }, [isRecording]);\n\n  // Smoothly auto-scroll the transcript container when new text is added.\n  useEffect(() => {\n    if (containerRef.current) {\n      containerRef.current.scrollTo({\n        top: containerRef.current.scrollHeight,\n        behavior: \"smooth\"\n      });\n    }\n  }, [finalTranscript, interimTranscript]);\n\n  // Send only the new finalized transcript chunk via WebSocket when updated.\n  useEffect(() => {\n    if (newFinalChunk.trim() !== \"\" && socket && socket.readyState === WebSocket.OPEN) {\n      try {\n        const message = JSON.stringify({\n          newTranscript: newFinalChunk\n        });\n        socket.send(message);\n        console.log(\"Sent final transcript chunk:\", message);\n        // Indicate for a brief moment that the message was sent.\n        setMessageStatus(\"Message sent\");\n        setTimeout(() => setMessageStatus(\"\"), 1000);\n        // Reset the new final chunk to avoid re-sending.\n        setNewFinalChunk(\"\");\n      } catch (err) {\n        console.error(\"Failed to send message:\", err);\n      }\n    }\n  }, [newFinalChunk, socket]);\n\n  // Toggle recording on/off.\n  const toggleRecording = () => {\n    if (isRecording) {\n      recognition.stop();\n    } else {\n      setInterimTranscript(\"\");\n      recognition.start();\n    }\n    setIsRecording(!isRecording);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"App\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"controls\",\n      children: [/*#__PURE__*/_jsxDEV(\"button\", {\n        className: \"mic-button\",\n        onClick: toggleRecording,\n        children: isRecording ? \"Stop\" : \"Record\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 226,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n        className: \"status\",\n        children: [connectionStatus, \" \", messageStatus && ` - ${messageStatus}`]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 229,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 225,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"text-container\",\n      ref: containerRef,\n      children: /*#__PURE__*/_jsxDEV(\"p\", {\n        className: \"transcript\",\n        children: [finalTranscript, \" \", /*#__PURE__*/_jsxDEV(\"span\", {\n          className: \"interim\",\n          children: interimTranscript\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 235,\n          columnNumber: 29\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 234,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 233,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 224,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"6DOFIrmG3rOu8ALo+VJZCmXxTqA=\");\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useState","useEffect","useRef","jsxDEV","_jsxDEV","isQuestionSentence","sentence","trim","length","words","split","firstWord","toLowerCase","startOnlyIndicators","generalIndicators","includes","secondWord","word","slice","formatSentence","isQuestion","charAt","toUpperCase","test","SpeechRecognition","window","webkitSpeechRecognition","recognition","continuous","interimResults","lang","App","_s","isRecording","setIsRecording","finalTranscript","setFinalTranscript","interimTranscript","setInterimTranscript","newFinalChunk","setNewFinalChunk","connectionStatus","setConnectionStatus","messageStatus","setMessageStatus","containerRef","socket","setSocket","ws","reconnectIntervalId","connect","WebSocket","onopen","console","log","clearInterval","onclose","setInterval","onerror","error","close","onresult","event","final","interim","i","resultIndex","results","transcript","isFinal","formattedFinal","prev","onend","start","refreshInterval","intervalID","stop","current","scrollTo","top","scrollHeight","behavior","readyState","OPEN","message","JSON","stringify","newTranscript","send","setTimeout","err","toggleRecording","className","children","onClick","fileName","_jsxFileName","lineNumber","columnNumber","ref","_c","$RefreshReg$"],"sources":["/Users/ayush/Desktop/Hacks/speech-to-text-app/src/App.js"],"sourcesContent":["import React, { useState, useEffect, useRef } from \"react\";\nimport \"./App.css\";\n\n// Helper function to determine if a sentence should be considered a question.\nfunction isQuestionSentence(sentence) {\n  sentence = sentence.trim();\n  if (sentence.length === 0) return false;\n\n  // Split the sentence into individual words.\n  const words = sentence.split(/\\s+/);\n  const firstWord = words[0].toLowerCase();\n\n  // Words that indicate a question only if they appear at the beginning.\n  const startOnlyIndicators = [\n    \"is\", \"are\", \"am\", \"was\", \"were\", \"do\", \"does\", \"did\",\n    \"can\", \"could\", \"would\", \"should\", \"will\", \"shall\"\n  ];\n  // Words that may indicate a question regardless of position.\n  const generalIndicators = [\"what\", \"why\", \"how\", \"when\", \"where\", \"who\"];\n\n  // Check if the first word is a question indicator.\n  if (startOnlyIndicators.includes(firstWord) || generalIndicators.includes(firstWord)) {\n    return true;\n  }\n  \n  // For sentences with at least 4 words, also check the second word for start-only indicators.\n  if (words.length >= 4) {\n    const secondWord = words[1].toLowerCase();\n    if (startOnlyIndicators.includes(secondWord)) {\n      return true;\n    }\n  }\n  \n  // Check the rest of the sentence for any general question indicators.\n  for (let word of words.slice(1)) {\n    if (generalIndicators.includes(word.toLowerCase())) {\n      return true;\n    }\n  }\n  \n  return false;\n}\n\n// Helper function to format a sentence by trimming, capitalizing, and adding punctuation.\nfunction formatSentence(sentence) {\n  sentence = sentence.trim();\n  if (sentence.length === 0) return \"\";\n  \n  const isQuestion = isQuestionSentence(sentence);\n  \n  // Capitalize the first letter.\n  sentence = sentence.charAt(0).toUpperCase() + sentence.slice(1);\n  \n  // Append punctuation if none exists.\n  if (!/[.!?]$/.test(sentence)) {\n    sentence += isQuestion ? \"?\" : \".\";\n  }\n  \n  return sentence;\n}\n\n// Set up the Web Speech API for speech recognition.\nconst SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\nconst recognition = new SpeechRecognition();\nrecognition.continuous = true;\nrecognition.interimResults = true;\nrecognition.lang = \"en-US\";\n\nfunction App() {\n  // States for recording and transcript data.\n  const [isRecording, setIsRecording] = useState(false);\n  const [finalTranscript, setFinalTranscript] = useState(\"\");\n  const [interimTranscript, setInterimTranscript] = useState(\"\");\n  // New state: only the newly finalized chunk.\n  const [newFinalChunk, setNewFinalChunk] = useState(\"\");\n\n  // States for connection and message statuses.\n  const [connectionStatus, setConnectionStatus] = useState(\"Disconnected\");\n  const [messageStatus, setMessageStatus] = useState(\"\");\n\n  // Ref for the transcript display (for auto-scrolling).\n  const containerRef = useRef(null);\n  \n  // State to hold the WebSocket instance.\n  const [socket, setSocket] = useState(null);\n\n  // WebSocket connection effect with reconnection every 5 seconds if disconnected.\n  useEffect(() => {\n    let ws; \n    let reconnectIntervalId;\n    \n    const connect = () => {\n      try {\n        ws = new WebSocket(\"ws://localhost:8080\"); // Update this URL as needed.\n        ws.onopen = () => {\n          console.log(\"Connected to WebSocket server\");\n          setConnectionStatus(\"Connected\");\n          setSocket(ws);\n          // Clear any running reconnection interval.\n          if (reconnectIntervalId) {\n            clearInterval(reconnectIntervalId);\n            reconnectIntervalId = null;\n          }\n        };\n        ws.onclose = () => {\n          console.log(\"WebSocket connection closed\");\n          setConnectionStatus(\"Disconnected\");\n          setSocket(null);\n          // If not already reconnecting, start trying every 5 seconds.\n          if (!reconnectIntervalId) {\n            reconnectIntervalId = setInterval(() => {\n              console.log(\"Attempting to reconnect to WebSocket server...\");\n              connect();\n            }, 5000);\n          }\n        };\n        ws.onerror = (error) => {\n          console.error(\"WebSocket error:\", error);\n          ws.close(); // Force a close to trigger the reconnect logic in onclose.\n        };\n      } catch (error) {\n        console.error(\"WebSocket connection error:\", error);\n        setConnectionStatus(\"Disconnected\");\n      }\n    };\n    \n    connect();\n    \n    // Cleanup on component unmount.\n    return () => {\n      if (reconnectIntervalId) clearInterval(reconnectIntervalId);\n      if (ws) ws.close();\n    };\n  }, []);\n\n  // Set up speech recognition event handlers.\n  useEffect(() => {\n    recognition.onresult = (event) => {\n      let final = \"\";\n      let interim = \"\";\n      // Process each result from speech recognition.\n      for (let i = event.resultIndex; i < event.results.length; i++) {\n        const transcript = event.results[i][0].transcript;\n        if (event.results[i].isFinal) {\n          final += transcript;\n        } else {\n          interim += transcript;\n        }\n      }\n      // If finalized text exists, format it, update cumulative transcript, and capture the new chunk.\n      if (final) {\n        const formattedFinal = formatSentence(final);\n        setFinalTranscript(prev => prev + \" \" + formattedFinal);\n        setNewFinalChunk(formattedFinal);\n      }\n      // Update interim text for real-time display.\n      setInterimTranscript(interim);\n    };\n\n    recognition.onerror = (event) => {\n      console.error(\"Speech recognition error:\", event.error);\n    };\n\n    recognition.onend = () => {\n      console.log(\"Speech recognition ended.\");\n      if (isRecording) {\n        console.log(\"Restarting speech recognition...\");\n        recognition.start();\n      }\n    };\n  }, [isRecording]);\n\n  // Periodically refresh the speech recognition session (every 50 seconds) to prevent browser timeout.\n  useEffect(() => {\n    if (!isRecording) return;\n    const refreshInterval = 50000; // 50 seconds.\n    const intervalID = setInterval(() => {\n      console.log(\"Refreshing recognition session...\");\n      recognition.stop();\n    }, refreshInterval);\n    return () => clearInterval(intervalID);\n  }, [isRecording]);\n\n  // Smoothly auto-scroll the transcript container when new text is added.\n  useEffect(() => {\n    if (containerRef.current) {\n      containerRef.current.scrollTo({\n        top: containerRef.current.scrollHeight,\n        behavior: \"smooth\",\n      });\n    }\n  }, [finalTranscript, interimTranscript]);\n\n  // Send only the new finalized transcript chunk via WebSocket when updated.\n  useEffect(() => {\n    if (newFinalChunk.trim() !== \"\" && socket && socket.readyState === WebSocket.OPEN) {\n      try {\n        const message = JSON.stringify({ newTranscript: newFinalChunk });\n        socket.send(message);\n        console.log(\"Sent final transcript chunk:\", message);\n        // Indicate for a brief moment that the message was sent.\n        setMessageStatus(\"Message sent\");\n        setTimeout(() => setMessageStatus(\"\"), 1000);\n        // Reset the new final chunk to avoid re-sending.\n        setNewFinalChunk(\"\");\n      } catch (err) {\n        console.error(\"Failed to send message:\", err);\n      }\n    }\n  }, [newFinalChunk, socket]);\n\n  // Toggle recording on/off.\n  const toggleRecording = () => {\n    if (isRecording) {\n      recognition.stop();\n    } else {\n      setInterimTranscript(\"\");\n      recognition.start();\n    }\n    setIsRecording(!isRecording);\n  };\n\n  return (\n    <div className=\"App\">\n      <div className=\"controls\">\n        <button className=\"mic-button\" onClick={toggleRecording}>\n          {isRecording ? \"Stop\" : \"Record\"}\n        </button>\n        <span className=\"status\">\n          {connectionStatus} {messageStatus && ` - ${messageStatus}`}\n        </span>\n      </div>\n      <div className=\"text-container\" ref={containerRef}>\n        <p className=\"transcript\">\n          {finalTranscript} <span className=\"interim\">{interimTranscript}</span>\n        </p>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}