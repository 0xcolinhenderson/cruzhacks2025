{"ast":null,"code":"var _jsxFileName = \"/Users/ayush/Desktop/Hacks/speech-to-text-app/src/App.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from \"react\";\nimport \"./App.css\";\nimport nlp from \"compromise\";\n\n// Use Compromise to segment text and format each sentence.\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction formatTranscript(text) {\n  // Segment the raw text into sentences.\n  const doc = nlp(text);\n  const sentences = doc.sentences().out(\"array\");\n\n  // Define a list of question words for the first-word check.\n  const questionIndicators = [\"what\", \"why\", \"how\", \"when\", \"where\", \"who\", \"do\", \"does\", \"did\", \"can\", \"could\", \"would\", \"should\", \"is\", \"are\", \"am\", \"will\", \"shall\"];\n\n  // Process each segmented sentence.\n  const formatted = sentences.map(sentence => {\n    let s = sentence.trim();\n    if (s.length === 0) return \"\";\n\n    // Capitalize the first letter.\n    s = s.charAt(0).toUpperCase() + s.slice(1);\n\n    // If it doesn't end with punctuation, determine if it's a question.\n    if (!/[.!?]$/.test(s)) {\n      // Split to get the first word.\n      const firstWord = s.split(\" \")[0].toLowerCase();\n      s += questionIndicators.includes(firstWord) ? \"?\" : \".\";\n    }\n    return s;\n  });\n\n  // Join the formatted sentences with a space.\n  return formatted.join(\" \");\n}\n\n// Set up the Web Speech API for speech recognition.\nconst SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\nconst recognition = new SpeechRecognition();\nrecognition.continuous = true;\nrecognition.interimResults = true;\nrecognition.lang = \"en-US\";\nfunction App() {\n  _s();\n  // States to manage recording and transcript data.\n  const [isRecording, setIsRecording] = useState(false);\n  const [finalTranscript, setFinalTranscript] = useState(\"\");\n  const [interimTranscript, setInterimTranscript] = useState(\"\");\n\n  // Ref for the transcript container (for auto-scrolling).\n  const containerRef = useRef(null);\n\n  // State for the WebSocket instance; null if unavailable.\n  const [socket, setSocket] = useState(null);\n\n  // Set up and manage the WebSocket connection with graceful fallback.\n  useEffect(() => {\n    let ws = null;\n    try {\n      // Replace with your actual WebSocket server URL.\n      ws = new WebSocket(\"ws://yourserveraddress:port\");\n      ws.onopen = () => {\n        console.log(\"Connected to WebSocket server\");\n      };\n      ws.onerror = error => {\n        console.error(\"WebSocket error:\", error);\n        setSocket(null);\n      };\n      setSocket(ws);\n    } catch (error) {\n      console.error(\"WebSocket connection error:\", error);\n      setSocket(null);\n    }\n    return () => {\n      if (ws) ws.close();\n    };\n  }, []);\n\n  // Set up speech recognition event handlers.\n  useEffect(() => {\n    recognition.onresult = event => {\n      let final = \"\";\n      let interim = \"\";\n      // Process each result returned by speech recognition.\n      for (let i = event.resultIndex; i < event.results.length; i++) {\n        const transcript = event.results[i][0].transcript;\n        if (event.results[i].isFinal) {\n          final += transcript;\n        } else {\n          interim += transcript;\n        }\n      }\n      // If there is finalized text, run it through the Compromise-based formatter.\n      if (final) {\n        const formattedFinal = formatTranscript(final);\n        setFinalTranscript(prev => prev + \" \" + formattedFinal);\n      }\n      // Update interim transcript for live UI feedback.\n      setInterimTranscript(interim);\n    };\n    recognition.onerror = event => {\n      console.error(\"Speech recognition error:\", event.error);\n    };\n\n    // When recognition ends, restart it if recording is still active.\n    recognition.onend = () => {\n      console.log(\"Speech recognition ended.\");\n      if (isRecording) {\n        console.log(\"Restarting speech recognition...\");\n        recognition.start();\n      }\n    };\n  }, [isRecording]);\n\n  // Refresh the speech recognition session periodically to prevent the browser timeout.\n  useEffect(() => {\n    if (!isRecording) return;\n    const refreshInterval = 50000; // Refresh every 50 seconds.\n    const intervalID = setInterval(() => {\n      console.log(\"Refreshing recognition session...\");\n      recognition.stop();\n    }, refreshInterval);\n    return () => clearInterval(intervalID);\n  }, [isRecording]);\n\n  // Auto-scroll the transcript container to the bottom on update.\n  useEffect(() => {\n    if (containerRef.current) {\n      containerRef.current.scrollTo({\n        top: containerRef.current.scrollHeight,\n        behavior: \"smooth\"\n      });\n    }\n  }, [finalTranscript, interimTranscript]);\n\n  // Send only the finalized transcript via WebSocket when updated.\n  useEffect(() => {\n    if (socket && socket.readyState === WebSocket.OPEN) {\n      try {\n        const message = JSON.stringify({\n          finalTranscript\n        });\n        socket.send(message);\n        console.log(\"Sent finalized transcript:\", message);\n      } catch (err) {\n        console.error(\"Failed to send message:\", err);\n      }\n    } else {\n      console.warn(\"WebSocket not available. Running without sending transcript.\");\n    }\n  }, [finalTranscript, socket]);\n\n  // Toggle recording on or off.\n  const toggleRecording = () => {\n    if (isRecording) {\n      recognition.stop();\n    } else {\n      setInterimTranscript(\"\");\n      recognition.start();\n    }\n    setIsRecording(!isRecording);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"App\",\n    children: [/*#__PURE__*/_jsxDEV(\"button\", {\n      className: \"mic-button\",\n      onClick: toggleRecording,\n      children: isRecording ? \"Stop\" : \"Record\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 167,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"text-container\",\n      ref: containerRef,\n      children: /*#__PURE__*/_jsxDEV(\"p\", {\n        className: \"transcript\",\n        children: [finalTranscript, \" \", /*#__PURE__*/_jsxDEV(\"span\", {\n          className: \"interim\",\n          children: interimTranscript\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 172,\n          columnNumber: 29\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 171,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 170,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 166,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"mqUJQ62LsOc8Do2ECH0cwbbkXhk=\");\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useState","useEffect","useRef","nlp","jsxDEV","_jsxDEV","formatTranscript","text","doc","sentences","out","questionIndicators","formatted","map","sentence","s","trim","length","charAt","toUpperCase","slice","test","firstWord","split","toLowerCase","includes","join","SpeechRecognition","window","webkitSpeechRecognition","recognition","continuous","interimResults","lang","App","_s","isRecording","setIsRecording","finalTranscript","setFinalTranscript","interimTranscript","setInterimTranscript","containerRef","socket","setSocket","ws","WebSocket","onopen","console","log","onerror","error","close","onresult","event","final","interim","i","resultIndex","results","transcript","isFinal","formattedFinal","prev","onend","start","refreshInterval","intervalID","setInterval","stop","clearInterval","current","scrollTo","top","scrollHeight","behavior","readyState","OPEN","message","JSON","stringify","send","err","warn","toggleRecording","className","children","onClick","fileName","_jsxFileName","lineNumber","columnNumber","ref","_c","$RefreshReg$"],"sources":["/Users/ayush/Desktop/Hacks/speech-to-text-app/src/App.js"],"sourcesContent":["import React, { useState, useEffect, useRef } from \"react\";\nimport \"./App.css\";\nimport nlp from \"compromise\";\n\n// Use Compromise to segment text and format each sentence.\nfunction formatTranscript(text) {\n  // Segment the raw text into sentences.\n  const doc = nlp(text);\n  const sentences = doc.sentences().out(\"array\");\n\n  // Define a list of question words for the first-word check.\n  const questionIndicators = [\n    \"what\", \"why\", \"how\", \"when\", \"where\", \"who\", \n    \"do\", \"does\", \"did\", \"can\", \"could\", \"would\", \n    \"should\", \"is\", \"are\", \"am\", \"will\", \"shall\"\n  ];\n\n  // Process each segmented sentence.\n  const formatted = sentences.map((sentence) => {\n    let s = sentence.trim();\n    if (s.length === 0) return \"\";\n\n    // Capitalize the first letter.\n    s = s.charAt(0).toUpperCase() + s.slice(1);\n\n    // If it doesn't end with punctuation, determine if it's a question.\n    if (!/[.!?]$/.test(s)) {\n      // Split to get the first word.\n      const firstWord = s.split(\" \")[0].toLowerCase();\n      s += questionIndicators.includes(firstWord) ? \"?\" : \".\";\n    }\n    return s;\n  });\n\n  // Join the formatted sentences with a space.\n  return formatted.join(\" \");\n}\n\n// Set up the Web Speech API for speech recognition.\nconst SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\nconst recognition = new SpeechRecognition();\nrecognition.continuous = true;\nrecognition.interimResults = true;\nrecognition.lang = \"en-US\";\n\nfunction App() {\n  // States to manage recording and transcript data.\n  const [isRecording, setIsRecording] = useState(false);\n  const [finalTranscript, setFinalTranscript] = useState(\"\");\n  const [interimTranscript, setInterimTranscript] = useState(\"\");\n  \n  // Ref for the transcript container (for auto-scrolling).\n  const containerRef = useRef(null);\n  \n  // State for the WebSocket instance; null if unavailable.\n  const [socket, setSocket] = useState(null);\n\n  // Set up and manage the WebSocket connection with graceful fallback.\n  useEffect(() => {\n    let ws = null;\n    try {\n      // Replace with your actual WebSocket server URL.\n      ws = new WebSocket(\"ws://yourserveraddress:port\");\n      ws.onopen = () => {\n        console.log(\"Connected to WebSocket server\");\n      };\n      ws.onerror = (error) => {\n        console.error(\"WebSocket error:\", error);\n        setSocket(null);\n      };\n      setSocket(ws);\n    } catch (error) {\n      console.error(\"WebSocket connection error:\", error);\n      setSocket(null);\n    }\n    return () => {\n      if (ws) ws.close();\n    };\n  }, []);\n\n  // Set up speech recognition event handlers.\n  useEffect(() => {\n    recognition.onresult = (event) => {\n      let final = \"\";\n      let interim = \"\";\n      // Process each result returned by speech recognition.\n      for (let i = event.resultIndex; i < event.results.length; i++) {\n        const transcript = event.results[i][0].transcript;\n        if (event.results[i].isFinal) {\n          final += transcript;\n        } else {\n          interim += transcript;\n        }\n      }\n      // If there is finalized text, run it through the Compromise-based formatter.\n      if (final) {\n        const formattedFinal = formatTranscript(final);\n        setFinalTranscript(prev => prev + \" \" + formattedFinal);\n      }\n      // Update interim transcript for live UI feedback.\n      setInterimTranscript(interim);\n    };\n\n    recognition.onerror = (event) => {\n      console.error(\"Speech recognition error:\", event.error);\n    };\n\n    // When recognition ends, restart it if recording is still active.\n    recognition.onend = () => {\n      console.log(\"Speech recognition ended.\");\n      if (isRecording) {\n        console.log(\"Restarting speech recognition...\");\n        recognition.start();\n      }\n    };\n  }, [isRecording]);\n\n  // Refresh the speech recognition session periodically to prevent the browser timeout.\n  useEffect(() => {\n    if (!isRecording) return;\n    const refreshInterval = 50000; // Refresh every 50 seconds.\n    const intervalID = setInterval(() => {\n      console.log(\"Refreshing recognition session...\");\n      recognition.stop();\n    }, refreshInterval);\n    return () => clearInterval(intervalID);\n  }, [isRecording]);\n\n  // Auto-scroll the transcript container to the bottom on update.\n  useEffect(() => {\n    if (containerRef.current) {\n      containerRef.current.scrollTo({\n        top: containerRef.current.scrollHeight,\n        behavior: \"smooth\"\n      });\n    }\n  }, [finalTranscript, interimTranscript]);\n\n  // Send only the finalized transcript via WebSocket when updated.\n  useEffect(() => {\n    if (socket && socket.readyState === WebSocket.OPEN) {\n      try {\n        const message = JSON.stringify({ finalTranscript });\n        socket.send(message);\n        console.log(\"Sent finalized transcript:\", message);\n      } catch (err) {\n        console.error(\"Failed to send message:\", err);\n      }\n    } else {\n      console.warn(\"WebSocket not available. Running without sending transcript.\");\n    }\n  }, [finalTranscript, socket]);\n\n  // Toggle recording on or off.\n  const toggleRecording = () => {\n    if (isRecording) {\n      recognition.stop();\n    } else {\n      setInterimTranscript(\"\");\n      recognition.start();\n    }\n    setIsRecording(!isRecording);\n  };\n\n  return (\n    <div className=\"App\">\n      <button className=\"mic-button\" onClick={toggleRecording}>\n        {isRecording ? \"Stop\" : \"Record\"}\n      </button>\n      <div className=\"text-container\" ref={containerRef}>\n        <p className=\"transcript\">\n          {finalTranscript} <span className=\"interim\">{interimTranscript}</span>\n        </p>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}